#!/usr/bin/python3
# -*- coding: utf-8 -*-

# built ins
import asyncio
from datetime import datetime, timedelta, timezone
import os,sys

# installed
from dataclassy import dataclass, fields
import json
from loguru import logger as log
import orjson
import tomli
import websockets
import signal
from multiprocessing import Manager
from multiprocessing.queues import Queue
from multiprocessing.queues import Queue
from multiprocessing import cpu_count
from aiomultiprocess import Pool
from aiomultiprocess import Pool

# user defined formula
from configuration import id_numbering, config, config_oci
from transaction_management.deribit.api_requests import (
    get_end_point_result,
    get_currencies,
    get_instruments,)
from transaction_management.deribit.get_instrument_summary import (
    get_futures_instruments,)
from transaction_management.deribit.telegram_bot import (
    telegram_bot_sendtext,)
from utilities.pickling import (
    replace_data,)
from utilities.system_tools import (
    async_raise_error_message,
    kill_process,
    provide_path_for_file,
    raise_error_message,)
from utilities.string_modification import (
    remove_double_brackets_in_list,
    remove_redundant_elements,)
from transaction_management.deribit.managing_deribit import (
    ModifyOrderDb,
    currency_inline_with_database_address,)

from utilities.string_modification import (
    extract_currency_from_text,
    remove_double_brackets_in_list,
    remove_redundant_elements,)
from transaction_management.deribit.data_producer import (
    StreamAccountData)

from utilities.caching import (
    combining_ticker_data as cached_ticker,
    update_cached_orders,
    combining_order_data,
    update_cached_ticker)


def parse_dotenv (sub_account) -> dict:
    return config.main_dotenv(sub_account)

def get_config(file_name: str) -> list:
    """ """
    config_path = provide_path_for_file (file_name)
    
    try:
        if os.path.exists(config_path):
            with open(config_path, "rb") as handle:
                read= tomli.load(handle)
                return read
    except:
        return []


async def update_db_pkl(
    path, 
    data_orders,
    currency
    ) -> None:

    my_path_portfolio = provide_path_for_file (path,
                                               currency)
        
    if currency_inline_with_database_address(
        currency,
        my_path_portfolio):
        
        replace_data (
            my_path_portfolio, 
            data_orders
            )

def get_settlement_period (strategy_attributes) -> list:
    
    return (remove_redundant_elements(
        remove_double_brackets_in_list(
            [o["settlement_period"]for o in strategy_attributes]))
            )
        
def handle_ctrl_c(
    signum, 
    stack_frame
    )->None:
    
    sys.exit(0)
    
                
@dataclass(unsafe_hash=True, slots=True)
class RunningStrategy(ModifyOrderDb):
    
    """_summary_
https://stackoverflow.com/questions/61216022/receiving-streaming-data-after-implementing-asyncio-websockets-as-a-class
    Returns:
        _type_: _description_
    """

    sub_account_id: str
    client_id: str = fields 
    client_secret: str = fields 
    modify_order_and_db: object = fields 
    # Async Event Loop
    loop = asyncio.get_event_loop()
    ws_connection_url: str = "wss://www.deribit.com/ws/api/v2"
    # Instance Variables
    connection_url: str = "https://www.deribit.com/api/v2/"
    websocket_client: websockets.WebSocketClientProtocol = None
    refresh_token: str = None
    refresh_token_expiry_time: int = None
    config_app: list = fields
            
    def __post_init__(self):
        self.modify_order_and_db: str = ModifyOrderDb(self.sub_account_id)
        self.client_id: str = parse_dotenv(self.sub_account_id)["client_id"]
        self.client_secret: str = config_oci.get_oci_key(parse_dotenv(self.sub_account_id)["key_ocid"])
        # parsing config file
        
        self.config_app = get_config("config_strategies.toml")
        # Start Primary Coroutine
        #self.loop.run_until_complete(self.ws_manager())
    
    async def ws_manager(
        self,
        message: object
        ) -> None:
        
        async with websockets.connect(
            self.ws_connection_url,
            ping_interval=None,
            compression=None,
            close_timeout=60,
        ) as self.websocket_client:
                
            try:
                    
                # parsing config file
                config_app = self.config_app
                
                # get tradable strategies
                tradable_config_app = config_app["tradable"]
                
                # get tradable currencies
                #currencies_spot= ([o["spot"] for o in tradable_config_app]) [0]
                currencies= ([o["spot"] for o in tradable_config_app]) [0]
                
                #currencies= random.sample(currencies_spot,len(currencies_spot))
                
                strategy_attributes = config_app["strategies"]
                
                strategy_attributes_active = [o for o in strategy_attributes \
                    if o["is_active"]==True]
                                            
                active_strategies =   [o["strategy_label"] for o in strategy_attributes_active]
                
                # get strategies that have not short/long attributes in the label 
                non_checked_strategies =   [o["strategy_label"] for o in strategy_attributes_active \
                    if o["non_checked_for_size_label_consistency"]==True]
                
                cancellable_strategies =   [o["strategy_label"] for o in strategy_attributes_active \
                    if o["cancellable"]==True]
                
                contribute_to_hedging_strategies =   [o["strategy_label"] for o in strategy_attributes_active \
                    if o["contribute_to_hedging"]==True]
                
                relevant_tables = config_app["relevant_tables"][0]
                
                trade_db_table= relevant_tables["my_trades_table"]
                
                order_db_table= relevant_tables["orders_table"]        
                                
                settlement_periods = get_settlement_period (strategy_attributes)
                
                futures_instruments = await get_futures_instruments (
                    currencies,
                    settlement_periods,
                    )  

                instrument_attributes_futures_all = futures_instruments["active_futures"]   
                
                instrument_attributes_combo_all = futures_instruments["active_combo"]  
                
                instruments_name = futures_instruments["instruments_name"]   
                
                min_expiration_timestamp = futures_instruments["min_expiration_timestamp"]   
                
                # filling currencies attributes
                my_path_cur = provide_path_for_file("currencies")
                replace_data(
                    my_path_cur,
                    currencies
                    )
                
                ticker_perpetual = cached_ticker(currencies)  
                
                orders_all = combining_order_data(currencies)  
                
                #log.warning (f"orders_all {orders_all}")
                    
                while True:
                               
                    # Authenticate WebSocket Connection
                    await self.ws_auth()

                    # Establish Heartbeat
                    await self.establish_heartbeat()

                    # Start Authentication Refresh Task
                    self.loop.create_task(self.ws_refresh_auth())
                    
                    # Start Data Stream Task
                    #log.error (f"message {message}")
                                        
                    message_channel = message["params"]["channel"]
                    
                    data_orders: list = message["params"]["data"] 
                    
                    
                    if "user.changes.any" in message_channel:
                        log.warning (f"data_orders {data_orders}")
                                            

                    if "chart.trades" in message_channel:
                        instrument_ticker = ((message_channel)[13:]).partition('.')[0] 
                        log.info (f"data_orders {data_orders}")
                                                    
    
                    instrument_ticker = (message_channel)[19:]  
                    if (
                        message_channel
                        == f"incremental_ticker.{instrument_ticker}"):
                        log.debug (f"data_orders {data_orders}")
                        
            except Exception as error:
                await raise_error_message (error)
                await telegram_bot_sendtext (
                    error,
                    "general_error")
              
  
    async def establish_heartbeat(self) -> None:
        """
        Requests DBT's `public/set_heartbeat` to
        establish a heartbeat connection.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 9098,
            "method": "public/set_heartbeat",
            "params": {"interval": 10},
        }

        try:
         
            await self.websocket_client.send(json.dumps(msg))
        
        except Exception as error:
            log.warning(error)

    async def heartbeat_response(self) -> None:
        """
        Sends the required WebSocket response to
        the Deribit API Heartbeat message.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 8212,
            "method": "public/test",
            "params": {},
        }
        
        #orjson_dump= (orjson.dumps(msg))
        
        #log.error (f" orjson_dump {orjson_dump}")
        json_dump= (json.dumps(msg))
        #log.error (f" json_dump {json_dump}")
        
        #message = await self.websocket_client.send(json.dumps(msg))
        
        #log.error (f"message {message}")
        
        try:
            await self.websocket_client.send(json.dumps(msg))

        except Exception as error:
            log.warning(error)

    async def ws_auth(self) -> None:
        """
        Requests DBT's `public/auth` to
        authenticate the WebSocket Connection.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 9929,
            "method": "public/auth",
            "params": {
                "grant_type": "client_credentials",
                "client_id": self.client_id,
                "client_secret": self.client_secret,
            },
        }
        
        
        try:
            await self.websocket_client.send(json.dumps(msg))

        except Exception as error:
        
            log.debug (error)
            #await sleep_and_restart ()
        
    async def ws_refresh_auth(self) -> None:
        """
        Requests DBT's `public/auth` to refresh
        the WebSocket Connection's authentication.
        """
        while True:
            now_utc = datetime.now(timezone.utc)
            if self.refresh_token_expiry_time is not None:
                if now_utc > self.refresh_token_expiry_time:
                    
                    msg: dict = {
                        "jsonrpc": "2.0",
                        "id": 9929,
                        "method": "public/auth",
                        "params": {
                            "grant_type": "refresh_token",
                            "refresh_token": self.refresh_token,
                        },
                    }
                    
                    await self.websocket_client.send(json.dumps(msg))

            await asyncio.sleep(150)
                            
                                    
    async def ws_operation(
        self, 
        operation: str, 
        ws_channel: str, 
        id: int = 100
    ) -> None:
        """
        Requests `public/subscribe` or `public/unsubscribe`
        to DBT's API for the specific WebSocket Channel.
        """
        sleep_time: int = 1
        
        await asyncio.sleep(sleep_time)
        id = id_numbering.id(operation, ws_channel)


        msg: dict = {
            "jsonrpc": "2.0",
            "method": f"private/{operation}",
            "id": id,
            "params": {"channels": [ws_channel]},
        }

        await self.websocket_client.send(json.dumps(msg))

                  
async def worker(sub_account_id,name: str, queue: Queue):
    while True:
        message = queue.get()
                        
        message_channel = message["params"]["channel"]
        
        data_orders: list = message["params"]["data"] 
        
        currency: str = extract_currency_from_text(message_channel)
                                    
        if message_channel == f"user.portfolio.{currency.lower()}":
            log.error (f"data_orders {data_orders}")
            
        
        if "user.changes.any" in message_channel:
            log.warning (f"data_orders {data_orders}")
                                

        if "chart.trades" in message_channel:
            instrument_ticker = ((message_channel)[13:]).partition('.')[0] 
            log.info (f"data_orders {data_orders}")
                                        

        instrument_ticker = (message_channel)[19:]  
        if (
            message_channel
            == f"incremental_ticker.{instrument_ticker}"):
            log.debug (f"data_orders {data_orders}")
            
        #running = RunningStrategy(sub_account_id)
        #await running.ws_manager(message)
        
                
    
async def main():
    
    try:
        
        queue: Queue = Manager().Queue()
        sub_account_id = "deribit-148510"
        
        num_consumers = cpu_count() 
        
        stream = StreamAccountData(sub_account_id)

        #result = await (stream.ws_manager(queue))
        producer_task = asyncio.create_task(stream.ws_manager(queue)) #(capture_data(queue))

        async with Pool() as pool:
            c_tasks = [pool.apply(worker, args=(sub_account_id,f"worker-{i}",queue)) 
                    for i in range(num_consumers)]
            await asyncio.gather(*c_tasks)

            await producer_task
            
    except Exception as error:
        log.critical (error)
        
        await async_raise_error_message(
            error,
            "WebSocket connection - failed to distribute_incremental_ticker_result_as_per_data_type",
        )
        
if __name__ == "__main__":
    
    
    try:
        signal.signal(signal.SIGINT, handle_ctrl_c) # terminate on ctrl-c
        print('Enter Ctrl-C to terminate.')
        
        asyncio.run(main())
        
    except(
        KeyboardInterrupt, 
        SystemExit
        ):
        asyncio.get_event_loop().run_until_complete(main().stop_ws())
        
    except Exception as error:
        log.critical (error)
        asyncio. telegram_bot_sendtext (
            error,
            "general_error"
            )
        raise_error_message(
        error, 
        3, 
        "app"
        )
