#!/usr/bin/python3
# -*- coding: utf-8 -*-

# built ins
import asyncio
from asyncio import Queue
import signal
import sys

# installed
import uvloop
import numpy as np
import redis.asyncio as aioredis

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

from streaming_helper.data_cleaning import app_data_cleaning
from configuration import config, config_oci
from streaming_helper.restful_api.deribit import end_point_params_template
from streaming_helper.restful_api import connector
from market_understanding.price_action.candles_analysis import get_market_condition
from streaming_helper.data_announcer.deribit import get_instrument_summary, starter
from streaming_helper.utilities import  error_handling,string_modification as str_mod,system_tools
from prettytable import PrettyTable

x = PrettyTable().get_html_string(attributes={"class":"table"}, format=True)

x.field_names = ["City name", "Area", "Population"]

x.add_row(["Adelaide", 1295, 1158259])
x.add_row(["Brisbane", 5905, 1857594])
x.add_row(["Darwin", 112, 120900])
x.add_row(["Hobart", 1357, 205556])
x.add_row(["Sydney", 2058, 4336374])
x.add_row(["Melbourne", 1566, 3806092])
x.add_row(["Perth", 5386, 1554769])

print(x)

def handle_ctrl_c(
    signum, 
    stack_frame
    )->None:
    
    sys.exit(0)
    
                  
signal_handler = system_tools.SignalHandler()

async def main():
    """
    """
    
    exchange = "deribit"
    
    sub_account_id = "deribit-148510"

    # registering strategy config file    
    file_toml = "config_strategies.toml"
        
    try:
    
        pool = aioredis.ConnectionPool.from_url(
            "redis://localhost", 
            port=6379, 
            db=0, 
            protocol=3, 
            encoding="utf-8",
            decode_responses=True
            )

        client_redis: object = aioredis.Redis.from_pool(pool)


        config_path = system_tools.provide_path_for_file(".env")
        
        parsed= config.main_dotenv(
            sub_account_id,
            config_path,
        )
                
        client_id: str = parsed["client_id"]
        client_secret: str = config_oci.get_oci_key(parsed["key_ocid"])

        #instantiate private connection
        api_request: object = end_point_params_template.SendApiRequest(client_id,client_secret)

        # parsing config file
        config_app = system_tools.get_config_tomli(file_toml)

        # get tradable strategies
        tradable_config_app = config_app["tradable"]

        # get TRADABLE currencies
        currencies: list = [o["spot"] for o in tradable_config_app][0]

        strategy_attributes = config_app["strategies"]

        relevant_tables = config_app["relevant_tables"][0]

        order_db_table = relevant_tables["orders_table"]

        cancellable_strategies = [
            o["strategy_label"] for o in strategy_attributes if o["cancellable"] == True
        ]

        settlement_periods = str_mod.remove_redundant_elements(
        str_mod.remove_double_brackets_in_list(
            [o["settlement_period"] for o in strategy_attributes]
        )
    )
        
        futures_instruments = await get_instrument_summary.get_futures_instruments(
            currencies,
            settlement_periods,
        )

        # get redis channels
        redis_channels: dict = config_app["redis_channels"][0]
        
        from streaming_helper.restful_api.telegram import (
    end_point_params_template as end_point_telegram,
)
        
        
        parsed= config.main_dotenv(
            sub_account_id,
            config_path,
        )
        sub_account_id = "telegram-general_error"
        client_id: str = parsed["bot_token"]
        client_secret: str= parsed["bot_chatID"]
        
        connection_url_telegram = end_point_telegram.basic_https()
                
        await connector.get_connected(
                            connection_url_telegram,
                            None,
                            client_id,
                            client_secret,
                            x,
                        )

        tes = f"<pre>{x}</pre>"
        
        print(tes)
        
        await connector.get_connected(
                            connection_url_telegram,
                            None,
                            client_id,
                            client_secret,
                            tes,
                        )


        #await starter.initial_procedures(
        #    private_data,
        #    config_app,
        #    )
        

        result_template = str_mod.message_template()
        
        sub_account_cached_channel: str = redis_channels["sub_account_cache_updating"]
        
        # sub_account_combining        
        sub_accounts = [await api_request.get_subaccounts_details(o) for o in currencies]

        initial_data_subaccount = starter.sub_account_combining(
            sub_accounts,
            sub_account_cached_channel,
            result_template,
        )

        resolutions: list = [o["resolutions"] for o in tradable_config_app][0]

        strategy_attributes = config_app["strategies"]
   
        await asyncio.sleep(0.0005)
        
        await asyncio.gather(
        
            app_data_cleaning.reconciling_size(
                client_id,
                client_secret,
                client_redis,
                redis_channels,
                config_app,
                initial_data_subaccount,
                futures_instruments,
                ),      
            
                        )  
   
    except Exception as error:
        
        await error_handling.parse_error_message_with_redis(
            client_redis,
            error,
            )

if __name__ == "__main__":
    
    try:
        signal.signal(signal.SIGINT, handle_ctrl_c) # terminate on ctrl-c
        
        uvloop.run(main())
        
    except(
        KeyboardInterrupt, 
        SystemExit
        ):
        
        asyncio.get_event_loop().run_until_complete(main())
        
    except Exception as error:
        asyncio.run (error_handling.parse_error_message_with_redis(
            client_redis,
            error,
            ))

