#!/usr/bin/env/python
# -*- coding: utf-8 -*-

import asyncio
from datetime import datetime, timedelta, timezone
import os
from secrets import randbelow
import random

# installed
from dataclassy import dataclass, fields
import json, orjson
from loguru import logger as log
import tomli
import websockets

from configuration import id_numbering, config
from configuration.label_numbering import get_now_unix_time
from data_cleaning.reconciling_db import (
    reconciling_orders,
    is_size_sub_account_and_my_trades_reconciled)
from db_management.sqlite_management import (
    executing_query_based_on_currency_or_instrument_and_strategy as get_query,
    executing_query_with_return,
    querying_table,
    update_status_data)
from strategies.basic_strategy import (
    get_label_integer,)
from strategies.hedging_spot import (
    HedgingSpot,
    get_market_condition_hedging)
from strategies.cash_carry.combo_auto import(
    ComboAuto,
    check_if_minimum_waiting_time_has_passed)
from transaction_management.deribit.api_requests import get_tickers
from transaction_management.deribit.managing_deribit import (
    ModifyOrderDb,)
from transaction_management.deribit.telegram_bot import (
    telegram_bot_sendtext,)
from transaction_management.deribit.get_instrument_summary import (
    get_futures_instruments,)
from utilities.pickling import (
    replace_data,
    read_data,)
from utilities.number_modification import get_closest_value
from utilities.string_modification import (
    extract_currency_from_text,
    parsing_label,
    remove_double_brackets_in_list,
    remove_redundant_elements)
from utilities.system_tools import (
    async_raise_error_message,
    provide_path_for_file,
    raise_error_message,
    sleep_and_restart,)

# Using the LRUCache decorator function with a maximum cache size of 3
def cached_ticker_data(currencies):
    """_summary_
    https://blog.apify.com/python-cache-complete-guide/]
    data caching
    https://medium.com/@ryan_forrester_/python-return-statement-complete-guide-138c80bcfdc7

    Args:
        instrument_ticker (_type_): _description_

    Returns:
        _type_: _description_
    """
    #result = (orjson.loads(data))
    
    
    
    result=[]
    for currency in currencies:
        instrument_name = f"{currency}-PERPETUAL"
                        
        result_instrument= reading_from_pkl_data(
                "ticker",
                instrument_name
                )
        
        if result_instrument:
            result_instrument = result_instrument[0]

        else:
            result_instrument = get_tickers (instrument_name)
        result.append (result_instrument)


    return result

def update_cached_ticker_data(
    instrument_name,
    ticker,
    data_orders):
    """_summary_
    https://stackoverflow.com/questions/73064997/update-values-in-a-list-of-dictionaries

    Args:
        instrument_ticker (_type_): _description_

    Returns:
        _type_: _description_
    """
    #result = (orjson.loads(data))
        
    instrument_ticker = [o for o in ticker if instrument_name in o["instrument_name"]]
    
    if instrument_ticker:
        
        for item in data_orders:
            if "stats" not in item and "instrument_name" not in item and "type" not in item:
                [o for o in ticker if instrument_name in o["instrument_name"]][0][item] = data_orders[item]
            #[o for o in ticker if instr
            if "stats"  in item:
                data_orders_stat = data_orders[item]
                for item in data_orders_stat:
                    [o for o in ticker if instrument_name in o["instrument_name"]][0]["stats"][item] = data_orders_stat[item]
    

def parse_dotenv (sub_account) -> dict:
    return config.main_dotenv(sub_account)
    
def get_config(file_name: str) -> list:
    """ """
    config_path = provide_path_for_file (file_name)
    
    try:
        if os.path.exists(config_path):
            with open(config_path, "rb") as handle:
                read= tomli.load(handle)
                return read
    except:
        return []


def reading_from_pkl_data(
    end_point, 
    currency,
    status: str = None
    ) -> dict:
    """ """

    path: str = provide_path_for_file (end_point,
                                      currency,
                                      status)
    data = read_data(path)

    return data


def compute_notional_value(
    index_price: float,
    equity: float
    ) -> float:
    """ """
    return index_price * equity



def get_index (
    data_orders: dict, 
    ticker: dict
    ) -> float:

    try:
        index_price= data_orders["index_price"]
        
    except:
        
        index_price= ticker["index_price"]
        
        if index_price==[]:
            index_price = ticker ["estimated_delivery_price"]
        
    return index_price


def get_settlement_period (strategy_attributes) -> list:
    
    return (remove_redundant_elements(
        remove_double_brackets_in_list(
            [o["settlement_period"]for o in strategy_attributes]))
            )
    
async def get_result_from_db_queries (
    currency,
    order_db_table,
    trade_db_table,
    transaction_log_trading,
    ) -> list:
    

    column_trade: str= "instrument_name,label, amount_dir as amount, price,side,timestamp,trade_id,is_open"
    query = f"SELECT {column_trade} FROM  {trade_db_table} WHERE is_open = 1 AND instrument_name LIKE '%{currency}%'"
    my_trades_currency: list= await executing_query_with_return (query)
                                                    
    column_list= "instrument_name", "position", "timestamp","trade_id","user_seq"        
    from_transaction_log = await get_query (transaction_log_trading, 
                                                currency, 
                                                "all", 
                                                "all", 
                                                column_list)                                       

    column_order= "instrument_name","label","amount","order_id","timestamp"
    orders_currency = await get_query(order_db_table, 
                                            currency, 
                                            "all", 
                                            "all", 
                                            column_order)     
    
    return dict(my_trades_currency=my_trades_currency,
                from_transaction_log=from_transaction_log,
                orders_currency=orders_currency)
    
    
def modify_hedging_instrument (
    strong_bearish:  bool,
    bearish:  bool,
    instrument_attributes_futures_for_hedging: list,
    ticker_perpetual_instrument_name: dict,
    currency_upper: str,
    ) -> dict:
    

    if bearish or not strong_bearish:
                                
        instrument_attributes_future = [o for o in instrument_attributes_futures_for_hedging 
                                        if "PERPETUAL" not in o["instrument_name"]\
                                            and currency_upper in o["instrument_name"]]
        
        if len(instrument_attributes_future) > 1:
            index_attributes = randbelow(2)
            instrument_attributes = instrument_attributes_future[index_attributes]
        else:
            instrument_attributes = instrument_attributes_future[0]
            
        instrument_name: str = instrument_attributes ["instrument_name"] 
        
        instrument_ticker: list = reading_from_pkl_data(
            "ticker",
            instrument_name
            )
                        
        #log.error (f"instrument_ticker {instrument_ticker}")
        if instrument_ticker:                    
            instrument_ticker = instrument_ticker[0]
            
        else:                    
            instrument_ticker =   get_tickers (instrument_name)
            
        return instrument_ticker

    else:
        return   ticker_perpetual_instrument_name
                
def future_spread_attributes (
    position_without_combo:  list,
    instrument_attributes_futures: list,
    currency_upper: str,
    notional: float,
    best_ask_prc: float,
    server_time: int,
    ) -> dict:

    #log.warning (currency_upper)    
    #log.info (notional)    
    #log.error ([o["instrument_name"] for o in instrument_attributes_futures if "PERP" not in o["instrument_name"] and currency_upper  in o["instrument_name"]]
    #          )       
    #log.error ([ (reading_from_pkl_data("ticker",  o["instrument_name"])) for o in instrument_attributes_futures if "PERP" not in o["instrument_name"] and currency_upper  in o["instrument_name"]]
    #          )    
    #log.debug ([ (reading_from_pkl_data("ticker",  o["instrument_name"]))[0] for o in instrument_attributes_futures if "PERP" not in o["instrument_name"] and currency_upper  in o["instrument_name"]]
    #          )    
    #log.warning ([ (reading_from_pkl_data("ticker",  o["instrument_name"]))[0]["mark_price"] for o in instrument_attributes_futures if "PERP" not in o["instrument_name"] and currency_upper  in o["instrument_name"]]
    #          )    
    
    return  [{'instrument_name':o['instrument_name'], 
              'is_weekly': o["settlement_period"]=="week", 
              'premium': (reading_from_pkl_data("ticker",  o["instrument_name"])[0]["mark_price"])   - best_ask_prc, 
              'contango':((reading_from_pkl_data("ticker",  o["instrument_name"])[0]["mark_price"])   - best_ask_prc) > 0, 
              'leverage_instrument': 0 if ([i["size"]/notional for i in position_without_combo if i["instrument_name"] == o["instrument_name"]]) == []\
                                else abs([i["size"]/notional for i in position_without_combo if i["instrument_name"] == o["instrument_name"]][0]), 
                'pct_premium_per_day':((reading_from_pkl_data("ticker", 
                                                              o["instrument_name"])[0]["mark_price"]) - best_ask_prc
                                                   )/((o["expiration_timestamp"] - server_time)/1000/60/60/24
                                                      )/best_ask_prc,
                                                   } for o in instrument_attributes_futures if "PERP" not in o["instrument_name"]\
                                                       and currency_upper  in o["instrument_name"]
                            ]
                
@dataclass(unsafe_hash=True, slots=True)
class RunningStrategy(ModifyOrderDb):

    sub_account_id: str
    client_id: str = fields 
    client_secret: str = fields 
    modify_order_and_db: object = fields 
    # Async Event Loop
    loop = asyncio.get_event_loop()
    ws_connection_url: str = "wss://www.deribit.com/ws/api/v2"
    # Instance Variables
    connection_url: str = "https://www.deribit.com/api/v2/"
    websocket_client: websockets.WebSocketClientProtocol = None
    refresh_token: str = None
    refresh_token_expiry_time: int = None
    config_app: list = fields
            
    def __post_init__(self):
        self.modify_order_and_db: str = ModifyOrderDb(self.sub_account_id)
        self.client_id: str = parse_dotenv(self.sub_account_id)["client_id"]
        self.client_secret: str = parse_dotenv(self.sub_account_id)["client_secret"]
        # parsing config file
        
        self.config_app = get_config("config_strategies.toml")
        # Start Primary Coroutine
        self.loop.run_until_complete(self.ws_manager())
    
    async def ws_manager(self) -> None:
        async with websockets.connect(
            self.ws_connection_url,
            ping_interval=None,
            compression=None,
            close_timeout=60,
        ) as self.websocket_client:
                
                
            try:
                    
                # parsing config file
                config_app = self.config_app
                
                # get tradable strategies
                tradable_config_app = config_app["tradable"]
                
                # get tradable currencies
                currencies_spot= ([o["spot"] for o in tradable_config_app]) [0]
                
                currencies= random.sample(currencies_spot,len(currencies_spot))
                
                strategy_attributes = config_app["strategies"]
                                            
                active_strategies =   [o["strategy_label"] for o in strategy_attributes \
                    if o["is_active"]==True]

                # get strategies that have not short/long attributes in the label 
                non_checked_strategies =   [o["strategy_label"] for o in strategy_attributes \
                    if o["non_checked_for_size_label_consistency"]==True]
                
                cancellable_strategies =   [o["strategy_label"] for o in strategy_attributes \
                    if o["cancellable"]==True]
                
                relevant_tables = config_app["relevant_tables"][0]
                
                trade_db_table= relevant_tables["my_trades_table"]
                
                order_db_table= relevant_tables["orders_table"]        
                                
                settlement_periods = get_settlement_period (strategy_attributes)
                                
                futures_instruments = get_futures_instruments (
                    currencies,
                    settlement_periods
                    )  
                
                instrument_attributes_futures_all = futures_instruments["active_futures"]   

                instrument_attributes_combo_all = futures_instruments["active_combo"]  
                
                #log.info (instrument_attributes_combo)

                instruments_name = futures_instruments["instruments_name"]   
                
                min_expiration_timestamp = futures_instruments["min_expiration_timestamp"]   
                
                resolution = 1                
                    
                # filling currencies attributes
                my_path_cur = provide_path_for_file("currencies")
                replace_data(
                    my_path_cur,
                    currencies
                    )
                
                while True:
                               
                    # Authenticate WebSocket Connection
                    await self.ws_auth()

                    # Establish Heartbeat
                    await self.establish_heartbeat()

                    # Start Authentication Refresh Task
                    self.loop.create_task(self.ws_refresh_auth())
                    
                    for currency in currencies:

                        self.loop.create_task(
                            self.ws_operation(
                                operation="subscribe",
                                ws_channel= f"incremental_ticker.{currency}-PERPETUAL",
                            ))
                        
                
                    ticker_perpetual = cached_ticker_data(currencies)    
                    
                    while self.websocket_client.open:
                        
                        try:
                                
                            # Receive WebSocket messages
                            message: bytes = await self.websocket_client.recv()
                            message: dict = orjson.loads(message)
                            #message_channel: str = None
                            #log.warning (message)
                            if "id" in list(message):
                                if message["id"] == 9929:
                                    
                                    if self.refresh_token is None:
                                        log.info ("Successfully authenticated WebSocket Connection")

                                    else:
                                        log.info ("Successfully refreshed the authentication of the WebSocket Connection")

                                    self.refresh_token = message["result"]["refresh_token"]

                                    # Refresh Authentication well before the required datetime
                                    if message["testnet"]:
                                        expires_in: int = 300
                                    else:
                                        expires_in: int = message["result"]["expires_in"] - 240

                                    now_utc = datetime.now(timezone.utc)
                                    
                                    self.refresh_token_expiry_time = now_utc + timedelta(
                                        seconds=expires_in
                                    )

                                elif message["id"] == 8212:
                                    # Avoid logging Heartbeat messages
                                    continue

                            elif "method" in list(message):
                                # Respond to Heartbeat Message
                                if message["method"] == "heartbeat":
                                    await self.heartbeat_response()

                            if "params" in list(message):
                                
                                if message["method"] != "heartbeat":

                                    data_orders: list = message["params"]["data"] 

                                    instrument_name_perpetual = data_orders["instrument_name"]
                                    
                                    currency: str = extract_currency_from_text(instrument_name_perpetual)
                                    
                                    currency_upper: str = currency.upper()
                                    currency_lower: str =currency
                                    
                                    archive_db_table= f"my_trades_all_{currency_lower}_json"
                                    
                                    transaction_log_trading_table= f"transaction_log_{currency_lower}_json"

                                    update_cached_ticker_data(
                                        instrument_name_perpetual,
                                        ticker_perpetual,
                                        data_orders
                                        )
                                    
                                    # get portfolio data  
                                    portfolio = reading_from_pkl_data (
                                        "portfolio",
                                        currency
                                        )[0]
                                    
                                    equity: float = portfolio["equity"]    
                                    
                                    ticker_perpetual_instrument_name = [o for o in ticker_perpetual \
                                        if instrument_name_perpetual == o["instrument_name"]][0]                                   
                                                                                        
                                    index_price= get_index (
                                        data_orders,
                                        ticker_perpetual_instrument_name
                                        )
                                    
                                    sub_account = reading_from_pkl_data(
                                        "sub_accounts",
                                        currency
                                        )
                                    
                                    sub_account = sub_account[0]
                                
                                    sub_account_orders = sub_account["open_orders"]
                                    
                                    len_sub_account_orders_all = len(sub_account_orders)
                                    
                                    log.error (f" len_sub_account_orders_all {len_sub_account_orders_all}")
                                                       
                                    transaction_log_trading_table = f"transaction_log_{currency_lower}_json"
                                    
                                    if sub_account :

                                        result_from_db_queries = await get_result_from_db_queries (
                                            currency,
                                            order_db_table, 
                                            archive_db_table,
                                            transaction_log_trading_table,)
                                        
                                        my_trades_currency_all_transactions: list= result_from_db_queries["my_trades_currency"]
                                                                                
                                        my_trades_currency_all: list= [o for o in my_trades_currency_all_transactions\
                                            if currency_upper in [o["instrument_name"] for o in instrument_attributes_futures_all]]
                                        
                                        orders_currency = result_from_db_queries["orders_currency"]     
                                        
                                        outstanding_order_id = remove_redundant_elements ([o["label"] for o in orders_currency])
                                        
                                        #len_outstanding_order_id = 0 if outstanding_order_id =[] \
                                        #    else len (outstanding_order_id)
                                            
                                        #log.critical (f"len_outstanding_order_id {len_outstanding_order_id}")    
                                        
                                        for label in outstanding_order_id:
                                            
                                            orders = ([o for o in orders_currency\
                                                if label in o["label"]])
                                            
                                            len_label = len(orders)
                                            
                                            if len_label >1:
                                                
                                                for order in orders:
                                                    log.critical (f"double ids {label}")
                                                    log.critical ([o for o in orders_currency if label in o["label"]])
                                                    await self. modify_order_and_db. cancel_by_order_id (
                                                        order_db_table,
                                                        order["order_id"]
                                                        )
                                                    break
                                        
                                        position = [o for o in sub_account["positions"]]
                                        #log.debug (f"position {position}")
                                        position_without_combo = [ o for o in position \
                                            if f"{currency_upper}-FS" not in o["instrument_name"]]
                                                                                
                                        server_time = get_now_unix_time()  
                                        
                                        size_perpetuals_reconciled = is_size_sub_account_and_my_trades_reconciled(
                                            position_without_combo,
                                            my_trades_currency_all,
                                            instrument_name_perpetual)
                                        
                                        if  index_price is not None \
                                            and equity > 0 :
                                    
                                            my_trades_currency: list= [ o for o in my_trades_currency_all \
                                                if o["label"] is not None] 
                                            
                                            my_trades= remove_redundant_elements([o["instrument_name"] for o in my_trades_currency ])
                                            my_labels= remove_redundant_elements([parsing_label(o["label"])["main"] for o in my_trades_currency ])
                                            
                                            for label in my_labels: 
                                                log.debug (f"label {label}")
                                                amount = sum([o["amount"] for o in my_trades_currency if label in o["label"]])
                                                                                                                                    
                                                log.debug (f"amount {amount}")
                                                
                                            log.debug (sum([o["amount"] for o in my_trades_currency]))
                                            for instrument in my_trades: 
                                                log.debug (f"instrument {instrument}")
                                                amount = sum([o["amount"] for o in my_trades_currency if instrument in o["instrument_name"]])
                                                                                                                                    
                                                log.debug (f"amount {amount}")
                                                
                                            ONE_PCT = 1 / 100
                                            
                                            THRESHOLD_DELTA_TIME_SECONDS = 120
                                            
                                            THRESHOLD_MARKET_CONDITIONS_COMBO = .01 * ONE_PCT
                                            
                                            INSTRUMENT_EXPIRATION_THRESHOLD = 60 * 8 # 8 hours
                                            
                                            ONE_SECOND = 1000
                                            
                                            ONE_MINUTE = ONE_SECOND * 60   
                                            
                                            notional: float = compute_notional_value(index_price, equity)
                                            
                                            TA_result_data_all = await querying_table("market_analytics_json")
                                            
                                            TA_result_data_only=  TA_result_data_all["list_data_only"]

                                            TA_result_data = [o for o in TA_result_data_only if currency_upper in o["instrument"]]                                                                                                    
                                                                                            
                                            tick_TA=  max([o["tick"] for o in TA_result_data])
                                                        
                                            delta_time = server_time-tick_TA
                                            
                                            delta_time_seconds = delta_time/ONE_SECOND   
                                            
                                            delta_time_expiration = min_expiration_timestamp - server_time  
                                            
                                            if delta_time_expiration < 0:
                                                
                                                await sleep_and_restart ()
                            
                                            if delta_time_seconds > THRESHOLD_DELTA_TIME_SECONDS:
                                                
                                                log.warning (f"delta_time_seconds < 120 {delta_time_seconds < THRESHOLD_DELTA_TIME_SECONDS} {delta_time_seconds} tick_TA {tick_TA}")
                                                
                                                await self.modify_order_and_db.cancel_the_cancellables(
                                                    order_db_table,
                                                    currency,
                                                    cancellable_strategies
                                                    )
                                                
                                            reconciliation_direction = ["from_sub_account_to_order_db","from_order_db_to_sub_account"]
                                            for  direction in reconciliation_direction:
                                                await reconciling_orders(
                                                    self.modify_order_and_db,
                                                    sub_account,
                                                    orders_currency,
                                                    direction,
                                                    order_db_table
                                                )

                                            for strategy in active_strategies:
                                                
                                                strategy_params= [o for o in strategy_attributes \
                                                if o["strategy_label"] == strategy][0]   
                                            
                                                threshold_market_condition: float = strategy_params ["delta_price_pct"]
                            
                                                my_trades_currency_strategy = [o for o in my_trades_currency \
                                                    if strategy in (o["label"]) ]
                                                
                                                orders_currency_strategy = [o for o in orders_currency \
                                                    if strategy in (o["label"]) ]
                                                                            
                                                #get_unpaired_transaction = get_unpaired_transaction(
                                                #my_trades_currency_strategy)
                                                
                                                if    "futureSpread" in strategy :
                                                
                                                    log.warning (f"strategy {strategy}-START")    
                                                    
                                                    strategy_params= [o for o in strategy_attributes \
                                                        if o["strategy_label"] == strategy][0]   
                                                                                                 
                                                    target_transaction_per_hour = 1/10
                                                    
                                                    max_order_currency = 2
                                                    
                                                    random_instruments_name = random.sample(([o for o in instruments_name\
                                                                                                if "-FS-" not in o and currency_upper in o]),
                                                                                            max_order_currency)
                                                                
                                                    tables = [archive_db_table, trade_db_table]
                                                                                        
                                                    combo_auto = ComboAuto(
                                                        strategy,
                                                        strategy_params,
                                                        orders_currency_strategy,
                                                        server_time,
                                                        my_trades_currency_strategy,
                                                        ticker_perpetual_instrument_name,
                                                        )
                                                    
                                                    TP_THRESHOLD = .1/100
                                                    
                                                    my_trades_currency_strategy_labels: list = [o["label"] for o in my_trades_currency_strategy  ]
                                                                
                                                    # send combo orders
                                                    for instrument_attributes_combo in instrument_attributes_combo_all:
                                                        
                                                        try:
                                                            instrument_name_combo = instrument_attributes_combo["instrument_name"]
                                                        
                                                            size_future_reconciled = is_size_sub_account_and_my_trades_reconciled(
                                                                position_without_combo,
                                                                my_trades_currency_all,
                                                                instrument_name_combo)
                                                        
                                                        except:
                                                            instrument_name_combo = None
                                                            
                                                        if  instrument_name_combo is not None and currency_upper in instrument_name_combo:
                                                            
                                                            instrument_name_future = f"{currency_upper}-{instrument_name_combo[7:][:7]}"

                                                            size_future_reconciled = is_size_sub_account_and_my_trades_reconciled(
                                                                position_without_combo,
                                                                my_trades_currency_all,
                                                                instrument_name_future)
                                                                                                                
                                                            ticker_combo= reading_from_pkl_data(
                                                                "ticker",
                                                                instrument_name_combo
                                                                )
                                                            
                                                            ticker_future= reading_from_pkl_data(
                                                                "ticker",
                                                                instrument_name_future
                                                                )
                                                                
                                                            if len_sub_account_orders_all < 50\
                                                                    and ticker_future and ticker_combo:
                                                                #and not reduce_only \
                                                                
                                                                ticker_combo= ticker_combo[0]

                                                                ticker_future= ticker_future[0]
                                                    
                                                                send_order: dict = await combo_auto.is_send_open_order_allowed_auto_combo(
                                                                    ticker_future,
                                                                    ticker_combo,
                                                                    notional,
                                                                    instrument_name_combo,
                                                                    instrument_attributes_futures_all,
                                                                    instrument_attributes_combo,
                                                                    target_transaction_per_hour
                                                                    )
                                                        
                                                                if send_order:
                                                                    await self.processing_orders(send_order)
                                                    
                                                                instrument_time_left = (max([o["expiration_timestamp"] for o in instrument_attributes_futures_all\
                                                                    if o["instrument_name"] == instrument_name_future])- server_time)/ONE_MINUTE  
                                                                
                                                                instrument_time_left_exceed_threshold = instrument_time_left > INSTRUMENT_EXPIRATION_THRESHOLD
                                                                                                                                 
                                                                if instrument_time_left_exceed_threshold\
                                                                    and instrument_name_future in  random_instruments_name \
                                                                        and size_perpetuals_reconciled\
                                                                            and size_future_reconciled\
                                                                                and size_future_reconciled:
                                                                            
                                                                    send_order: dict = await combo_auto.is_send_open_order_constructing_manual_combo_allowed(
                                                                        ticker_future,
                                                                        instrument_attributes_futures_all,
                                                                        notional,
                                                                        target_transaction_per_hour,
                                                                        min(1,max_order_currency)
                                                                        )
                                                            
                                                                    if send_order:
                                                                        await self.processing_orders(send_order)
                                                    
                                                    # get labels from active trades
                                                    labels=  remove_redundant_elements(my_trades_currency_strategy_labels)
                        
                                                    #! closing active trades
                                                    for label in labels:
                                                        
                                                        label_integer: int = get_label_integer (label)
                                                        selected_transaction = [o for o in my_trades_currency_strategy \
                                                            if str(label_integer) in o["label"]]
                                                        
                                                        selected_transaction_amount = ([o["amount"] for o in selected_transaction])
                                                        sum_selected_transaction = sum(selected_transaction_amount)
                                                        len_selected_transaction = len(selected_transaction_amount)
                                                        
                                                        #! closing combo auto trading
                                                        if "Auto" in label and len_sub_account_orders_all < 50:
                                                            
                                                            TP_THRESHOLD = TP_THRESHOLD * 10
                                                            
                                                            if sum_selected_transaction == 0:                                                               
                                                                send_order: dict = await combo_auto.is_send_exit_order_allowed_combo_auto (
                                                                label,
                                                                instrument_attributes_combo_all,
                                                                TP_THRESHOLD)
                                                                
                                                                await self.processing_orders(send_order)
                                                                
                                                            else:                                                               
                                                                
                                                                new_label = f"futureSpread-open-{label_integer}"
                                                            
                                                                filter = "label"
                                                                
                                                                for table in tables:
                                                                    await update_status_data(
                                                                        table,
                                                                        "label",
                                                                        filter,
                                                                        label,
                                                                        new_label,
                                                                        "="
                                                                        )
                                                                  
                                                                log.debug ("renaming combo Auto done")
                                                                
                                                                await self.modify_order_and_db.cancel_the_cancellables(
                                                                    order_db_table,
                                                                    currency,
                                                                    cancellable_strategies
                                                                    )
                                                            
                                                        #! renaming combo auto trading
                                                        else:
                                                        
                                                            #log.debug (f"selected_transaction {selected_transaction}")
                                                            #log.critical (f"sum_selected_transaction {sum_selected_transaction}")
                                                                        
                                                            if sum_selected_transaction == 0:
                                                                if "open" in label:
                                                                    new_label = f"futureSpreadAuto-open-{label_integer}"
                                                            
                                                                if "closed" in label:
                                                                    new_label = f"futureSpreadAuto-closed-{label_integer}"
                                                            
                                                                filter = "label"
                                                                
                                                                for table in tables:
                                                                    await update_status_data(
                                                                        table,
                                                                        "label",
                                                                        filter,
                                                                        label,
                                                                        new_label,
                                                                        "="
                                                                        )
                                                            
                                                            #! closing unpaired transactions                                                            
                                                            else:
                                                                
                                                                if len_selected_transaction == 1 \
                                                                    and "closed" not in label:
                                                                    
                                                                    send_order = []
                                                                                                                                    
                                                                    if size_perpetuals_reconciled\
                                                                        and delta_time_seconds < THRESHOLD_DELTA_TIME_SECONDS:
                                                            
                                                                        for transaction in selected_transaction:
                                                                                                                                  
                                                                            waiting_minute_before_ordering = strategy_params["waiting_minute_before_cancel"] * ONE_MINUTE 
                                                                            
                                                                            timestamp: int = transaction["timestamp"]
                                                                        
                                                                            waiting_time_for_selected_transaction: bool = check_if_minimum_waiting_time_has_passed(
                                                                                    waiting_minute_before_ordering,
                                                                                    timestamp,
                                                                                    server_time,
                                                                                ) * 2

                                                                            instrument_name = transaction["instrument_name"]
                                                                            
                                                                            ticker_transaction= reading_from_pkl_data(
                                                                                "ticker",
                                                                                instrument_name
                                                                                )
                                                                            
                                                                            if ticker_transaction and len_sub_account_orders_all < 50:
                                                                                
                                                                                TP_THRESHOLD = TP_THRESHOLD * 5
                                                                                
                                                                                send_order: dict = await combo_auto.is_send_contra_order_for_unpaired_transaction_allowed(
                                                                                    ticker_transaction[0],
                                                                                    instrument_attributes_futures_all,
                                                                                    TP_THRESHOLD,
                                                                                    transaction,
                                                                                    waiting_time_for_selected_transaction,
                                                                                    THRESHOLD_MARKET_CONDITIONS_COMBO,
                                                                                    random_instruments_name
                                                                                    )
                                                            
                                                                                if send_order["order_allowed"]:
                                                                                
                                                                                    await self.processing_orders(send_order)
                                                        
                                                                                    break            
                                                            
                                                    if orders_currency_strategy:
                                                        for order in orders_currency_strategy:
                                                            cancel_allowed: dict = await combo_auto.is_cancelling_orders_allowed(
                                                                order,
                                                                server_time,
                                                                )
                                                            if cancel_allowed["cancel_allowed"]:
                                                                await self.modify_order_and_db.if_cancel_is_true(
                                                                    order_db_table,
                                                                    cancel_allowed)
                                                                    
                                                    log.warning (f"strategy {strategy}-DONE")
                                                
                                                if "hedgingSpot" in strategy \
                                                    and size_perpetuals_reconciled:
                                                    
                                                    log.warning (f"strategy {strategy}-START")                                                    
                                                    
                                                    instrument_attributes_futures_for_hedging = [o for o in futures_instruments["active_futures"] \
                                                        if o["settlement_period"] != "month" and\
                                                            o["kind"] == "future"] 
                                                              
                                                    market_condition: dict = await get_market_condition_hedging(
                                                        TA_result_data,
                                                        index_price,
                                                        threshold_market_condition
                                                        )
                                                    
                                                    strong_bearish = market_condition["strong_falling_price"]
                                                
                                                    bearish = market_condition["falling_price"]
                                                    #log.error (f"market_condition {market_condition}")
                                                                                                        
                                                    instrument_ticker =   modify_hedging_instrument (
                                                        strong_bearish,
                                                        bearish,
                                                        instrument_attributes_futures_for_hedging,
                                                        ticker_perpetual_instrument_name,
                                                        currency_upper)
                                                                
                                                    instrument_name = instrument_ticker ["instrument_name"]    
                                                        
                                                    size_future_reconciled = is_size_sub_account_and_my_trades_reconciled(
                                                        position_without_combo,
                                                        my_trades_currency_all,
                                                        instrument_name)
   
                                                    max_position: int = notional * -1
                                                         
                                                    hedging = HedgingSpot(
                                                        strategy,
                                                        strategy_params,
                                                        max_position,
                                                        my_trades_currency_strategy,
                                                        TA_result_data,
                                                        index_price,
                                                        )
                                                                                                            
                                                    if size_future_reconciled:      
                                                
                                                        instrument_time_left = (max([o["expiration_timestamp"] for o in instrument_attributes_futures_all\
                                                            if o["instrument_name"] == instrument_name])- server_time)/ONE_MINUTE  
                                                        
                                                        instrument_time_left_exceed_threshold = instrument_time_left > INSTRUMENT_EXPIRATION_THRESHOLD
                                                                                                                
                                                        #something was wrong because perpetuals were actively traded. cancell  orders
                                                        if instrument_time_left_exceed_threshold\
                                                            and len_sub_account_orders_all < 50\
                                                                and delta_time_seconds < THRESHOLD_DELTA_TIME_SECONDS:
                                                            
                                                            my_trades_currency_strategy_open = [o for o in my_trades_currency_strategy \
                                                                if "open" in (o["label"])]
                                                            
                                                            orders_currency_strategy_label_closed = [o for o in orders_currency_strategy \
                                                                if "closed" in (o["label"]) ]
                                                            
                                                            best_ask_prc: float = instrument_ticker["best_ask_price"] 
    
                                                            send_order: dict = await hedging.is_send_open_order_allowed(
                                                                non_checked_strategies,
                                                                instrument_name,
                                                                instrument_attributes_futures_for_hedging,
                                                                orders_currency_strategy,
                                                                best_ask_prc,
                                                                archive_db_table,
                                                                trade_db_table
                                                                
                                                                )
                                                            
                                                            await self.processing_orders(send_order)
                                                                
                                                            if my_trades_currency_strategy_open !=[]:
                                                                                                                                            
                                                                best_bid_prc: float = instrument_ticker["best_bid_price"]
                                                                
                                                                get_prices_in_label_transaction_main = [o["price"] for o in my_trades_currency_strategy_open]
                                                                
                                                                closest_price = get_closest_value(
                                                                    get_prices_in_label_transaction_main,
                                                                    best_bid_prc
                                                                    )

                                                                nearest_transaction_to_index = [o for o in my_trades_currency_strategy_open \
                                                                    if o["price"] == closest_price]
                                                                
                                                                instrument_ticker: list = reading_from_pkl_data(
                                                                    "ticker",
                                                                    nearest_transaction_to_index[0]["instrument_name"])
                                                                
                                                                if len_sub_account_orders_all < 50\
                                                                    and instrument_ticker:

                                                                    send_closing_order: dict = await hedging.is_send_exit_order_allowed(
                                                                        orders_currency_strategy_label_closed,
                                                                        instrument_ticker[0]["best_bid_price"],
                                                                        nearest_transaction_to_index,
                                                                        orders_currency_strategy
                                                                        )

                                                                    await self.processing_orders(send_closing_order)
                            
                                                    if orders_currency_strategy:
                                                        
                                                        for order in orders_currency_strategy:
                                                            cancel_allowed: dict = await hedging.is_cancelling_orders_allowed(
                                                                order,
                                                                orders_currency_strategy,
                                                                server_time,
                                                                )
                                                            log.critical (f"cancel_allowed {cancel_allowed}")
                                                            if cancel_allowed["cancel_allowed"]:
                                                                await self.modify_order_and_db.if_cancel_is_true(
                                                                    order_db_table,
                                                                    cancel_allowed
                                                                    )
                                                        
                                                    log.warning (f"strategy {strategy}-DONE")
                                            
                                            
                                            #my_trades_currency_active_free_blanks = [o for o in my_trades_currency\
                                            #if o["label"] is not None]
                                            
                                            #await clean_up_closed_transactions(
                                            #    currency, 
                                            #    trade_db_table,
                                            # closed_table,
                                            #    my_trades_currency_active_free_blanks
                                            #    )
                                                        
                        except Exception as error:
                            await raise_error_message (error)
                            await telegram_bot_sendtext (
                                error,
                                "general_error")

            except Exception as error:
                await raise_error_message (error)
                await telegram_bot_sendtext (
                    error,
                    "general_error")
              
              
    async def processing_orders(
        self,
        order_analysis_result: dict,
        ) -> None:
        """
        """
        
        try:
            
            if order_analysis_result["order_allowed"]:
                    
                log.error (f"send_order {order_analysis_result}")

                # parsing config file
                config_app = self.config_app
                
                strategy_attributes = config_app["strategies"]
                
                # get strategies that have not short/long attributes in the label 
                non_checked_strategies =   [o["strategy_label"] for o in strategy_attributes \
                    if o["non_checked_for_size_label_consistency"]==True]
                                                                                    
                result_order = await self.modify_order_and_db.if_order_is_true(
                    non_checked_strategies,
                    order_analysis_result, 
                    )
                
                if result_order:
                    #log.error (f"result_order {result_order}")
                    
                    try:
                        data_orders = result_order["result"]
                        
                        try:
                            instrument_name = data_orders["order"]["instrument_name"]

                        except:
                            instrument_name = data_orders["trades"]["instrument_name"]

                        currency = extract_currency_from_text (instrument_name)
                        
                        transaction_log_trading_table= f"transaction_log_{currency.lower()}_json"
                        
                        archive_db_table= f"my_trades_all_{currency.lower()}_json"
                        
                        
                        relevant_tables = config_app["relevant_tables"][0]
                                                    
                        trade_db_table= relevant_tables["my_trades_table"]
                        
                        order_db_table= relevant_tables["orders_table"]           
                
                        await self.modify_order_and_db.update_user_changes_non_ws(
                            non_checked_strategies,
                            data_orders, 
                            order_db_table,
                            trade_db_table, 
                            archive_db_table,
                            transaction_log_trading_table)
            
                    except Exception as error :
                        pass 
                    
                    await sleep_and_restart ()
                    
        except Exception as error:
            log.warning(error)
                    
  
    async def establish_heartbeat(self) -> None:
        """
        Requests DBT's `public/set_heartbeat` to
        establish a heartbeat connection.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 9098,
            "method": "public/set_heartbeat",
            "params": {"interval": 10},
        }

        try:
         
            await self.websocket_client.send(json.dumps(msg))
        
        except Exception as error:
            log.warning(error)

    async def heartbeat_response(self) -> None:
        """
        Sends the required WebSocket response to
        the Deribit API Heartbeat message.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 8212,
            "method": "public/test",
            "params": {},
        }
        
        #orjson_dump= (orjson.dumps(msg))
        
        #log.error (f" orjson_dump {orjson_dump}")
        json_dump= (json.dumps(msg))
        #log.error (f" json_dump {json_dump}")
        
        #message = await self.websocket_client.send(json.dumps(msg))
        
        #log.error (f"message {message}")
        
        try:
            await self.websocket_client.send(json.dumps(msg))

        except Exception as error:
            log.warning(error)

    async def ws_auth(self) -> None:
        """
        Requests DBT's `public/auth` to
        authenticate the WebSocket Connection.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 9929,
            "method": "public/auth",
            "params": {
                "grant_type": "client_credentials",
                "client_id": self.client_id,
                "client_secret": self.client_secret,
            },
        }
        
        
        try:
            await self.websocket_client.send(json.dumps(msg))

        except Exception as error:
        
            log.debug (error)
            await sleep_and_restart ()
        
    async def ws_refresh_auth(self) -> None:
        """
        Requests DBT's `public/auth` to refresh
        the WebSocket Connection's authentication.
        """
        while True:
            now_utc = datetime.now(timezone.utc)
            if self.refresh_token_expiry_time is not None:
                if now_utc > self.refresh_token_expiry_time:
                    
                    msg: dict = {
                        "jsonrpc": "2.0",
                        "id": 9929,
                        "method": "public/auth",
                        "params": {
                            "grant_type": "refresh_token",
                            "refresh_token": self.refresh_token,
                        },
                    }
                    
                    await self.websocket_client.send(json.dumps(msg))

            await asyncio.sleep(150)
                            
                                    
    async def ws_operation(
        self, 
        operation: str, 
        ws_channel: str, 
        id: int = 100
    ) -> None:
        """
        Requests `public/subscribe` or `public/unsubscribe`
        to DBT's API for the specific WebSocket Channel.
        """
        sleep_time: int = 1
        
        await asyncio.sleep(sleep_time)
        id = id_numbering.id(operation, ws_channel)


        msg: dict = {
            "jsonrpc": "2.0",
            "method": f"private/{operation}",
            "id": id,
            "params": {"channels": [ws_channel]},
        }

        await self.websocket_client.send(json.dumps(msg))

def main():
    # https://www.codementor.io/@jflevesque/python-asynchronous-programming-with-asyncio-library-eq93hghoc
    sub_account_id = "deribit-148510"
    
    try:
        RunningStrategy(sub_account_id)

    except Exception as error:
        raise_error_message (
            error, 
            5,
            "app"
            )
                
if __name__ == "__main__":
    
    try:
        (main())
        
    except(
        KeyboardInterrupt, 
        SystemExit
        ):
        asyncio.get_event_loop().run_until_complete(main().stop_ws())
        

    except Exception as error:
        raise_error_message(
        error, 
        5, 
        "app"
        )
