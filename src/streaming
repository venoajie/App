#!/usr/bin/python3
# -*- coding: utf-8 -*-

# built ins
import asyncio
import sys

# installed
from loguru import logger as log
import signal
from multiprocessing import Manager
from multiprocessing.queues import Queue
from multiprocessing import cpu_count
from aiomultiprocess import Pool

from transaction_management.deribit.data_producer import (
    StreamAccountData,)
from transaction_management.deribit.loading_data_to_db import (
    processing_orders,)
from transaction_management.deribit.data_processor import (
    running_transactions,)
from transaction_management.deribit.telegram_bot import (
    telegram_bot_sendtext,)
from transaction_management.deribit.telegram_bot import (
    telegram_bot_sendtext,)
from utilities.system_tools import (
    async_raise_error_message,
    parse_error_message,
    SignalHandler)
        
def handle_ctrl_c(
    signum, 
    stack_frame
    )->None:
    
    sys.exit(0)
    
                  
signal_handler = SignalHandler()

async def main():
    
    sub_account_id = "deribit-148510"
    
    try:
        
        queue: Queue = Manager().Queue()
        
        num_consumers = max(1,int (cpu_count() / 4) - 1)
        
        stream = StreamAccountData(sub_account_id)

        producer_task = asyncio.create_task(stream.ws_manager(queue)) 
        
        async with Pool(maxtasksperchild=1) as pool:
            
            while signal_handler.KEEP_PROCESSING:
       
                processing_orders_tasks = [pool.apply(
                    processing_orders, 
                    args=(sub_account_id,
                          f"worker-{i}",
                          queue)) 
                                           for i in range(num_consumers)]
       
                running_transactions_tasks = [pool.apply(
                    running_transactions, 
                    args=(sub_account_id,
                          f"worker-{i}",
                          queue)) 
                                           for i in range(num_consumers)]
                
                await asyncio.gather(*processing_orders_tasks,
                                     *running_transactions_tasks)
                
                await asyncio.sleep(0.5)

                await producer_task
                
                pool.close()
                
                await pool.join()
            
    except Exception as error:
        log.critical (error)
        
        await async_raise_error_message(
            error,
            "WebSocket connection - failed to distribute_incremental_ticker_result_as_per_data_type",
        )
        
if __name__ == "__main__":
    
    
    try:
        signal.signal(signal.SIGINT, handle_ctrl_c) # terminate on ctrl-c
        
        asyncio.run(main())
        
    except(
        KeyboardInterrupt, 
        SystemExit
        ):
        
        asyncio.get_event_loop().run_until_complete(main().stop_ws())
        
    except Exception as error:
        parse_error_message(error)
        
        asyncio.run(telegram_bot_sendtext (
            error,
            "general_error"
            ))
