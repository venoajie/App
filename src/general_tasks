#!/usr/bin/env/python
# -*- coding: utf-8 -*-

import asyncio
import os

import httpx
from loguru import logger as log
import tomli

from configuration.label_numbering import get_now_unix_time
from db_management.sqlite_management import (
    back_up_db_sqlite,
    executing_query_based_on_currency_or_instrument_and_strategy as get_query,
    insert_tables, 
    querying_arithmetic_operator,
    querying_table)
from market_understanding.technical_analysis import (
    insert_market_condition_result)
from strategies.hedging_spot import (
    HedgingSpot,
    get_market_condition_hedging)
from transaction_management.deribit.api_requests import (
    get_currencies,
    get_instruments,)
from transaction_management.deribit.managing_deribit import (
    ModifyOrderDb,)
from transaction_management.deribit.telegram_bot import (
    telegram_bot_sendtext,)
from utilities.number_modification import get_closest_value
from utilities.pickling import (
    read_data,
    replace_data,)
from utilities.string_modification import (
    remove_double_brackets_in_list,
    remove_redundant_elements,
    transform_nested_dict_to_list,)
from utilities.system_tools import (
    async_raise_error_message,
    provide_path_for_file,
    raise_error_message,
    sleep_and_restart)
from websocket_management.allocating_ohlc import (
    ohlc_end_point, 
    ohlc_result_per_time_frame,
    last_tick_fr_sqlite,)
from websocket_management.cleaning_up_transactions import (
    check_whether_order_db_reconciled_each_other,
    check_whether_size_db_reconciled_each_other,
    get_unrecorded_trade_transactions,
    get_unrecorded_trade_and_order_id,
    count_and_delete_ohlc_rows,
    reconciling_sub_account_and_db_open_orders)
from websocket_management.ws_management import (
    get_futures_instruments,
    )
    
    
def get_config(file_name: str) -> list:
    """ """
    config_path = provide_path_for_file (file_name)
    
    try:
        if os.path.exists(config_path):
            with open(config_path, "rb") as handle:
                read= tomli.load(handle)
                return read
    except:
        return []

def check_cpu_usage(threshold):
    
    import psutil
    import smtplib

    cpu_usage = psutil.cpu_percent()
    if cpu_usage > threshold:
        send_alert(f"CPU usage is too high: {cpu_usage}%")
        
def get_index (
    data_orders: dict, 
    ticker: dict
    ) -> float:

    try:
        index_price= data_orders["index_price"]
        
    except:
        
        index_price= ticker["index_price"]
        
        if index_price==[]:
            index_price = ticker ["estimated_delivery_price"]
        
    return index_price


def get_settlement_period (strategy_attributes) -> list:
    
    return (remove_redundant_elements(
        remove_double_brackets_in_list(
            [o["settlement_period"]for o in strategy_attributes]))
            )

def compute_notional_value(
    index_price: float,
    equity: float
    ) -> float:
    """ """
    return index_price * equity

def reading_from_pkl_data(
    end_point, 
    currency,
    status: str = None
    ) -> dict:
    """ """

    path: str = provide_path_for_file (end_point,
                                      currency,
                                      status)

    return read_data(path)


async def back_up_db(idle_time):
    extensions = ('.bak')
    
    while True:

        folder_path = "databases/"

        try:
            file_list = os.listdir(folder_path)
                        
            for currentFile in file_list:
                #log.error(currentFile)
                if ".bak" in currentFile:
                    os.remove(f"{folder_path}{currentFile}")
            await back_up_db_sqlite ()
            
        except Exception as error:
            await raise_error_message(error)
            
        await asyncio.sleep(idle_time)
    

async def get_currencies_from_deribit() -> float:
    """ """

    return await get_currencies()


async def get_instruments_from_deribit(currency) -> float:
    """ """

    result = await get_instruments(currency)

    return result


async def get_result_from_db_queries (
    currency,
    order_db_table,
    trade_db_table,
    transaction_log_trading,
    ) -> list:
    

    column_trade: str= "instrument_name","label", "amount", "price","side"
    my_trades_currency: list= await get_query(trade_db_table, 
                                                currency, 
                                                "all", 
                                                "all", 
                                                column_trade)
                                                    
    column_list= "instrument_name", "position", "timestamp","trade_id","user_seq"        
    from_transaction_log = await get_query (transaction_log_trading, 
                                                currency, 
                                                "all", 
                                                "all", 
                                                column_list)                                       

    column_order= "instrument_name","label","amount","order_id","timestamp"
    orders_currency = await get_query(order_db_table, 
                                            currency, 
                                            "all", 
                                            "all", 
                                            column_order)     
    
    return dict(my_trades_currency=my_trades_currency,
                from_transaction_log=from_transaction_log,
                orders_currency=orders_currency)
    
async def clean_up_databases(idle_time) -> None:
    """ """

    while True:
                    
        log.critical("count_and_delete_ohlc_rows-START")
        tables = ["market_analytics_json", 
                "ohlc1_eth_perp_json", 
                "ohlc1_btc_perp_json", 
                "ohlc15_eth_perp_json", 
                "ohlc15_btc_perp_json", 
                "ohlc30_eth_perp_json", 
                "ohlc60_eth_perp_json",
                "ohlc3_eth_perp_json", 
                "ohlc3_btc_perp_json", 
                "ohlc5_eth_perp_json", 
                "ohlc5_btc_perp_json",]
        
        database: str = "databases/trading.sqlite3"  

        for table in tables:
                
            await count_and_delete_ohlc_rows(
                database,
                table
                )
        
        await asyncio.sleep(idle_time)


async def update_ohlc_and_market_condition(
    tradable_config_app,
    idle_time
    ) -> None:
    """ """   

    ONE_PCT = 1 / 100
    WINDOW = 9
    RATIO = 0.9
    THRESHOLD = 0.01 * ONE_PCT
    try:
        
        currencies = [o["spot"] for o in tradable_config_app] [0]
        end_timestamp =     get_now_unix_time() 
        
        while True:
                
            for currency in currencies:
                
                instrument_name= f"{currency}-PERPETUAL"

                await insert_market_condition_result(
                    instrument_name, 
                    WINDOW, 
                    RATIO)
                
                time_frame= [3,5,15,60,30,"1D"]
                    
                ONE_SECOND = 1000
                
                one_minute = ONE_SECOND * 60
                
                WHERE_FILTER_TICK: str = "tick"
                
                for resolution in time_frame:
                    
                    table_ohlc= f"ohlc{resolution}_{currency.lower()}_perp_json" 
                                
                    last_tick_query_ohlc_resolution: str = querying_arithmetic_operator (
                        WHERE_FILTER_TICK, 
                        "MAX",
                        table_ohlc
                        )
                    
                    start_timestamp: int = await last_tick_fr_sqlite (last_tick_query_ohlc_resolution)
                    
                    if resolution == "1D":
                        delta= (end_timestamp - start_timestamp)/(one_minute * 60 * 24)
                
                    else:
                        delta= (end_timestamp - start_timestamp)/(one_minute * resolution)
                                
                    if delta > 1:
                        end_point = ohlc_end_point(instrument_name,
                                        resolution,
                                        start_timestamp,
                                        end_timestamp,
                                        )
                        
                        with httpx.Client() as client:
                            ohlc_request = client.get(
                                end_point, 
                                follow_redirects=True
                                ).json()["result"]
                        
                        result = [o for o in transform_nested_dict_to_list(ohlc_request) \
                            if o["tick"] > start_timestamp][0]

                        await ohlc_result_per_time_frame (
                            instrument_name,
                            resolution,
                            result,
                            table_ohlc,
                            WHERE_FILTER_TICK, 
                            )

                        await insert_tables(
                            table_ohlc, 
                            result
                            )
            
            await asyncio.sleep(idle_time)
    
    except Exception as error:
        await raise_error_message(error)

async def get_instruments_from_deribit(currency) -> float:
    """ """

    result = await get_instruments(currency)

    return result

async def update_instruments(idle_time):

    try:
        
        while True:

            get_currencies_all = await get_currencies_from_deribit()
            currencies = [o["currency"] for o in get_currencies_all["result"]]

            for currency in currencies:

                instruments = await get_instruments_from_deribit(currency)

                my_path_instruments = provide_path_for_file("instruments", 
                                                            currency)

                replace_data(
                    my_path_instruments,
                    instruments
                    )

            my_path_cur = provide_path_for_file("currencies")

            replace_data(
                my_path_cur,
                currencies
                )
            
            await asyncio.sleep(idle_time)

    except Exception as error:
        await async_raise_error_message(error)

async def hedging_spot_currency(
    currency: str,
    currencies: list,
    config_app: list,
    modify_order_and_db: object,
    orders_currency: list,
    my_trades_currency: str,
    order_db_table: str,
    trade_db_table: str,
    archive_db_table: str,
    transaction_log_trading_table: str
    ) -> None:
    
    strategy="hedgingSpot"

    log.debug (f"strategy {strategy} {currency.upper()}-START")
    
    try:
        log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
        instrument_ticker: str = (f"{currency}-PERPETUAL")
        log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
    
        TA_result_data_all = await querying_table("market_analytics_json")
        log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")

        TA_result_data_only=  TA_result_data_all["list_data_only"]
        log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
        
        TA_result_data = [o for o in TA_result_data_only if currency in o["instrument"]]                                                                                                    
                                                        
        tick_TA=  max([o["tick"] for o in TA_result_data])
        log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
        
        perpetual_ticker: list = reading_from_pkl_data(
            "ticker",
            instrument_ticker
            )
                            
        # get portfolio data  
        portfolio: list = reading_from_pkl_data(
            "portfolio",
            currency
            )
        log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
        
        equity: float = portfolio[0]["equity"]    
        
        log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
        log.error (f"equity {equity}")
        
                        
        if  equity > 0\
                and perpetual_ticker:
            
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
                
            perpetual_ticker = perpetual_ticker[0]
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            log.error (f"perpetual_ticker {perpetual_ticker}")
            index_price: float = perpetual_ticker ["index_price"]  
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            
            strategy_params= [o for o in strategy_attributes if o["strategy_label"] == strategy][0]   

            log.error (f"strategy_params {strategy_params}")
                            
            threshold_market_condition: float = strategy_params ["delta_price_pct"]

            
            market_condition: dict = await get_market_condition_hedging(
                TA_result_data,
                index_price,
                threshold_market_condition
                )
            
            log.error (f"market_condition {market_condition}")
            
            
            
            strategy_attributes = config_app["strategies"]
                    
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            # get strategies that have not short/long attributes in the label 
            non_checked_strategies =   [o["strategy_label"] for o in strategy_attributes \
                if o["non_checked_for_size_label_consistency"]==True]
            
            cancellable_strategies =   [o["strategy_label"] for o in strategy_attributes \
                if o["cancellable"]==True]
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            
            settlement_periods= get_settlement_period (strategy_attributes)
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            
            futures_instruments =  get_futures_instruments (currencies,
                                                                settlement_periods)  
            
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            active_futures = futures_instruments["active_futures"]   

            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            notional: float = compute_notional_value(
                index_price, 
                equity
                )
            
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            my_trades_currency_strategy = [o for o in my_trades_currency if strategy in (o["label"]) ]
            
            max_position: int = notional * -1
            
            server_time = get_now_unix_time()  
               
            delta_time = server_time-tick_TA
            
            delta_time_seconds = delta_time/1000                                                
            log.warning ("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
                            
            THRESHOLD_DELTA_TIME_SECONDS = 120
            log.warning (f"delta_time_seconds < 120 {delta_time_seconds < THRESHOLD_DELTA_TIME_SECONDS} {delta_time_seconds} tick_TA {tick_TA} server_time {server_time}")
            
            #something was wrong because perpetuals were actively traded. cancell  orders
            if delta_time_seconds > THRESHOLD_DELTA_TIME_SECONDS:
                await modify_order_and_db.cancel_the_cancellables(
                    currency,
                    cancellable_strategies
                    )
                                                        
            else:   #ensure freshness of ta
                
                my_trades_currency_strategy_open = [o for o in my_trades_currency_strategy if "open" in (o["label"])]
                
                orders_currency_strategy = [o for o in orders_currency if strategy in (o["label"]) ]
                
                orders_currency_strategy_label_closed = [o for o in orders_currency_strategy if "closed" in (o["label"]) ]
                
                best_ask_prc: float = perpetual_ticker["best_ask_price"] 

                hedging = HedgingSpot(
                    strategy,
                    strategy_params,
                    max_position,
                    my_trades_currency_strategy,
                    TA_result_data,
                    index_price,
                    )
                
                for order in orders_currency_strategy:
                    cancel_allowed: dict = await hedging.is_cancelling_orders_allowed(
                        order,
                        orders_currency_strategy,
                        server_time,
                        )
                    
                    if cancel_allowed["cancel_allowed"]:
                        await modify_order_and_db.if_cancel_is_true(cancel_allowed)
                    
                send_order: dict = await hedging.is_send_open_order_allowed(
                    non_checked_strategies,
                    instrument_ticker,
                    active_futures,
                    orders_currency_strategy,
                    best_ask_prc,
                    )
                
                if send_order["order_allowed"]:
                    
                    result_order = await modify_order_and_db.if_order_is_true(
                        non_checked_strategies,
                        send_order, 
                        instrument_ticker
                        )

                    if result_order:
                        
                        log.error (f"result_order {result_order}")
                        
                        data_orders = result_order["result"]
                        await modify_order_and_db.update_user_changes_non_ws(
                            non_checked_strategies,
                            data_orders, 
                            currency,
                            order_db_table,
                            trade_db_table,
                            archive_db_table,
                            transaction_log_trading_table
                            )
                        
                        await sleep_and_restart ()
                    
                if my_trades_currency_strategy_open !=[]:
                                                                                                
                    best_bid_prc: float = perpetual_ticker["best_bid_price"]
                    
                    get_prices_in_label_transaction_main = [o["price"] for o in my_trades_currency_strategy_open]
                    
                    closest_price = get_closest_value(
                        get_prices_in_label_transaction_main,
                        best_bid_prc
                        )

                    nearest_transaction_to_index = [o for o in my_trades_currency_strategy_open \
                        if o["price"] == closest_price]
                    
                    send_closing_order: dict = await hedging.is_send_exit_order_allowed(
                        orders_currency_strategy_label_closed,
                        best_bid_prc,
                        nearest_transaction_to_index,
                        )

                    log.error (f"send_closing_order {send_closing_order}")
                    result_order = await modify_order_and_db.if_order_is_true(
                        non_checked_strategies,
                        send_closing_order, 
                        instrument_ticker,
                        )
                    
                    if result_order:
                        log.error (f"result_order {result_order}")
                        data_orders = result_order["result"]

                        await modify_order_and_db.update_user_changes_non_ws(
                            non_checked_strategies,
                            data_orders, 
                            currency, 
                            order_db_table,
                            trade_db_table, 
                            archive_db_table,
                            transaction_log_trading_table)

                        await sleep_and_restart ()
                        
            log.debug (f"strategy {strategy}-DONE")
    
    except Exception as error:
        await telegram_bot_sendtext (
                    error,
                    "general_error")
        await async_raise_error_message(error)
                


async def reconciling_orders_based_on_sources(
    modify_order_and_db: object,
    currency: str,
    orders_instrument_name: list,
    sub_account: list,
    orders_currency: list,
    order_db_table: str
    ) -> None:
    

    for instrument_name in (orders_instrument_name):
        #log.error (f"instrument_name {instrument_name}")
        len_order_is_reconciled_each_other =  check_whether_order_db_reconciled_each_other(
            sub_account,
            instrument_name,
            orders_currency
            )
        
        if not len_order_is_reconciled_each_other:
            log.warning (f"instrument_name {instrument_name} len_order_is_reconciled_each_other {len_order_is_reconciled_each_other}")
                        
            sub_account_from_exchange = await modify_order_and_db.get_sub_account (currency)                        
                        
            sub_account_from_exchange = sub_account_from_exchange[0]

            log.error (f"sub_account_from_exchange {sub_account_from_exchange}")

            await reconciling_sub_account_and_db_open_orders(
                instrument_name,
                order_db_table,
                orders_currency,
                sub_account_from_exchange
                )

            my_path_sub_account = provide_path_for_file(
                "sub_accounts",
                currency)
            
            replace_data(
                my_path_sub_account,
                sub_account_from_exchange
                )

async def reconciling_size_and_orders(
    sub_account_id: str,
    config_app: list,
    idle_time: int
    ) -> None:

                
    try:
        # get tradable strategies
        tradable_config_app = config_app["tradable"]
        
        # get tradable currencies
        currencies= [o["spot"] for o in tradable_config_app] [0]
        
        strategy_attributes = config_app["strategies"]
        
        modify_order_and_db = ModifyOrderDb(sub_account_id)
            
        while True:
            
            for currency in currencies:
                
                sub_account = reading_from_pkl_data(
                    "sub_accounts",
                    currency)
                
                sub_account = [] if not sub_account else sub_account[0]
                
                if sub_account:

                    trade_db_table= "my_trades_all_json"
                    
                    order_db_table= "orders_all_json"
                    
                    currency_lower = currency.lower ()
                    
                    archive_db_table = f"my_trades_all_{currency_lower}_json"                    
                    
                    transaction_log_trading_table = f"transaction_log_{currency_lower}_json"                                        

                    result_from_db_queries = await get_result_from_db_queries (
                        currency,
                        order_db_table, 
                        trade_db_table,
                        transaction_log_trading_table,)
                    
                    my_trades_currency: list= result_from_db_queries["my_trades_currency"]
                                                                    
                    from_transaction_log = result_from_db_queries["from_transaction_log"]                          

                    orders_currency = result_from_db_queries["orders_currency"]     
                    
                    orders_instrument_name = remove_redundant_elements(
                        [o["instrument_name"] for o in orders_currency]
                        )
                
                    # sources: order db
                    if orders_instrument_name:
                        await reconciling_orders_based_on_sources(
                            modify_order_and_db,
                            currency,
                            orders_instrument_name,
                            sub_account,
                            orders_currency,
                            order_db_table
                            )
                    
                    sub_account_orders = sub_account["open_orders"]
                    
                    sub_account_orders_instrument = remove_redundant_elements(
                        [o["instrument_name"] for o in sub_account_orders ]
                        )
                        
                    # sources: sub account
                    if sub_account_orders_instrument:
                        await reconciling_orders_based_on_sources(
                            modify_order_and_db,
                            currency,
                            sub_account_orders_instrument,
                            sub_account,
                            orders_currency,
                            order_db_table
                            )

                    from_transaction_log_instrument_name_only = remove_redundant_elements(
                        [o["instrument_name"] for o in from_transaction_log ]
                        )
                    
                    my_trades_instrument_name_only = remove_redundant_elements(
                        [o["instrument_name"] for o in my_trades_currency]
                        )
                    
                    #usually needef after db reconciliation, which transaction log more update than my_trading
                    if from_transaction_log_instrument_name_only:

                        for instrument_name in from_transaction_log_instrument_name_only:
                            
                            size_is_reconciled_each_other_all = check_whether_size_db_reconciled_each_other(
                                sub_account,
                                instrument_name,
                                my_trades_currency,
                                from_transaction_log
                                )
                            
                            size_is_reconciled_each_other = size_is_reconciled_each_other_all["different_from_all_db_sources"]
                            
                            if not size_is_reconciled_each_other:
                                
                                column_trade: str= "instrument_name","label","timestamp", "trade_id"
                                my_trades_instrument_name: list= await get_query(archive_db_table, 
                                                                            instrument_name, 
                                                                            "all", 
                                                                            "all", 
                                                                            column_trade)
                                    
                                if not  size_is_reconciled_each_other_all["different_from_sub_accont_and_trans_log"]:
                                    
                                    await modify_order_and_db. resupply_sub_accountdb(currency)
                                    
                                    await modify_order_and_db.resupply_transaction_log(
                                        currency,
                                        transaction_log_trading_table,
                                        instrument_name,
                                        100
                                        )
                                else:
                                    from_transaction_log_instrument_name = (
                                        [o for o in from_transaction_log if o["instrument_name"] == instrument_name]
                                        )  
                                    
                                    unrecorded_trade_id_from_transaction_log = get_unrecorded_trade_transactions(
                                        "from_trans_log_to_my_trade",
                                        my_trades_instrument_name,
                                        from_transaction_log_instrument_name
                                        )
                                    
                                    if unrecorded_trade_id_from_transaction_log:
                                        
                                        timestamp_log = min(
                                            [o["timestamp"] for o in from_transaction_log_instrument_name \
                                                if o["trade_id"] in unrecorded_trade_id_from_transaction_log]
                                            )
                                        
                                        log.warning (f"timestamp_log {timestamp_log}")
                                    
                                        await modify_order_and_db.update_trades_from_exchange_based_on_latest_timestamp (
                                            instrument_name,
                                            timestamp_log-10, # - x: arbitrary, timestamp in trade and transaction_log not always identical each other
                                            archive_db_table
                                            )
                                                                                                    
                                        unrecorded_transactions = await get_unrecorded_trade_and_order_id (instrument_name)  
                                        
                                        for transaction  in unrecorded_transactions:

                                            await insert_tables(
                                                trade_db_table,
                                                transaction
                                                )

                                    
                                        await modify_order_and_db. resupply_sub_accountdb(currency)
                                        await modify_order_and_db.resupply_transaction_log(
                                            currency,
                                            transaction_log_trading_table,
                                            instrument_name,
                                            100
                                            )

                    if my_trades_instrument_name_only:

                        for instrument_name in my_trades_instrument_name_only:
                            
                            size_is_reconciled_each_other_all = check_whether_size_db_reconciled_each_other(
                                sub_account,
                                instrument_name,
                                my_trades_currency,
                                from_transaction_log
                                )
                            
                            size_is_reconciled_each_other = size_is_reconciled_each_other_all["different_from_all_db_sources"]
                            
                            if not size_is_reconciled_each_other:
                                
                                if not  size_is_reconciled_each_other_all["different_from_sub_accont_and_trans_log"]:
                                    
                                    await modify_order_and_db. resupply_sub_accountdb(currency)
                                    await modify_order_and_db.resupply_transaction_log(
                                        currency,
                                        transaction_log_trading_table,
                                        instrument_name,
                                        100)

                                else:
                                    column_trade: str= "instrument_name","label","timestamp","trade_id"
                                    my_trades_instrument_name: list= await get_query(archive_db_table, 
                                                                                instrument_name, 
                                                                                "all", 
                                                                                "all", 
                                                                                column_trade)
                                    
                                    from_transaction_log_instrument =(
                                        [o for o in from_transaction_log \
                                            if o["instrument_name"] == instrument_name]
                                        )     
                                    
                                    unrecorded_trade_id_from_transaction_log = get_unrecorded_trade_transactions(
                                        "from_trans_log_to_my_trade",
                                        my_trades_instrument_name,
                                        from_transaction_log_instrument
                                        )
                                    
                                    for trade_id in unrecorded_trade_id_from_transaction_log:

                                        timestamp_log = max(
                                            [ o["timestamp"] for o in from_transaction_log_instrument \
                                                if trade_id == o["trade_id"]]
                                            )
                                    
                                        await modify_order_and_db.update_trades_from_exchange_based_on_latest_timestamp (
                                            instrument_name,
                                            timestamp_log-10, # - x: arbitrary, timestamp in trade and transaction_log not always identical each other
                                            archive_db_table
                                            )
                                        log.debug (f"instrument_name {instrument_name} size_is_reconciled_each_other {size_is_reconciled_each_other}")
                                        
                                    last_time_stamp_log = 0 if from_transaction_log_instrument == [] \
                                        else (max(
                                            [(o["timestamp"]) for o in from_transaction_log_instrument ])
                                              )
                                    
                                    last_time_my_trades = 0 if my_trades_instrument_name == []\
                                        else (max(
                                            [(o["timestamp"]) for o in my_trades_instrument_name ])
                                              )
                                    
                                    min_last_time_as_download_basis = min (last_time_stamp_log, 
                                                                            last_time_my_trades) - (1000 * 1000)
                    
                                    log.debug (f"last_time_stamp_log {last_time_stamp_log} last_time_my_trades {last_time_my_trades} min_last_time_as_download_basis {min_last_time_as_download_basis}")

                                    if min_last_time_as_download_basis:
                                        
                                        await modify_order_and_db.update_trades_from_exchange_based_on_latest_timestamp (
                                        instrument_name,
                                        min_last_time_as_download_basis,
                                        archive_db_table
                                        )
                                
                                    unrecorded_transactions = await get_unrecorded_trade_and_order_id (instrument_name)  
                                    
                                    for transaction  in unrecorded_transactions:

                                        await insert_tables(
                                            trade_db_table,
                                            transaction
                                            )
                                    
                                    await modify_order_and_db. resupply_sub_accountdb(currency)
                                    await modify_order_and_db.resupply_transaction_log(
                                        currency,
                                        transaction_log_trading_table,
                                        instrument_name,
                                        100
                                        )
                                                    
                    await hedging_spot_currency(
                        currency,
                        currencies,
                        config_app,
                        modify_order_and_db,
                        orders_currency,
                        my_trades_currency,
                        order_db_table,
                        trade_db_table,
                        archive_db_table,
                        transaction_log_trading_table
                    )
                                
            await asyncio.sleep(idle_time)
            
    except Exception as error:
        await async_raise_error_message(error)
        await telegram_bot_sendtext (
                    error,
                    "general_error")
                
    
async def main():
    
    sub_account_id = "deribit-148510"    
    
    # registering strategy config file    
    file_toml = "config_strategies.toml"
    
    # parsing config file
    config_app = get_config(file_toml)

    # get tradable strategies
    tradable_config_app = config_app["tradable"]

    try:
        await asyncio.gather(
        reconciling_size_and_orders(
            sub_account_id,
            config_app,
            2
            ),
        update_ohlc_and_market_condition(
            tradable_config_app, 
            15), 
        back_up_db(60*10),
        clean_up_databases(5), 
        update_instruments(60),
        return_exceptions=True)
    
    except Exception as error:
        await telegram_bot_sendtext (
                    error,
                    "general_error")
        await async_raise_error_message(error)
                
if __name__ == "__main__":
    
    try:
        #asyncio.run(main())
        asyncio.run(main())
        
    except (KeyboardInterrupt, SystemExit):
        asyncio.get_event_loop().run_until_complete(main().stop_ws())
        

    except Exception as error:
        raise_error_message(
        error, 
        10, 
        "app"
        )

    